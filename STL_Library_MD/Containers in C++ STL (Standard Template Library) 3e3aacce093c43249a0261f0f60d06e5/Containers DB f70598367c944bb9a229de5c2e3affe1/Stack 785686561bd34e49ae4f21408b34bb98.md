# Stack

Stackler, LIFO (LAST IN FIRST OUT) Ã§alÄ±ÅŸma tÃ¼rÃ¼ne sahip bir tÃ¼r container adaptÃ¶rÃ¼dÃ¼r.

Burada yeni bir eleman bir uca (Ã¼st) eklenir ve bir eleman yalnÄ±zca bu uÃ§tan Ã§Ä±karÄ±lÄ±r.  Stack, temel kapsayÄ±cÄ± olarak vektÃ¶r veya deque (varsayÄ±lan olarak) veya liste (sÄ±ralÄ± kapsayÄ±cÄ± sÄ±nÄ±fÄ±) kapsÃ¼llenmiÅŸ bir nesne kullanÄ±r ve Ã¶ÄŸelerine eriÅŸmek iÃ§in belirli bir Ã¼ye iÅŸlev kÃ¼mesi saÄŸlar.

<aside>
ğŸ’¡ Bu metin biraz kafa karÄ±ÅŸÄ±klÄ±ÄŸÄ±na neden olmuÅŸ olabilir. Burada aÃ§Ä±klamaya Ã§alÄ±ÅŸtÄ±ÄŸÄ± iÃ§in aÅŸaÄŸÄ±daki toggle listi aÃ§.

</aside>

- Kafan KarÄ±ÅŸtÄ±ysa oku.
    
    Stack iÃ§erisinde farklÄ± veri tÃ¼rleri tutabilir. Genellikle bu kullanÄ±lan veri tÃ¼rleri vektÃ¶r/deque gibi dinamik diziler ya da listeler gibi sÄ±ralÄ± veri yapÄ±larÄ± kullanÄ±lÄ±r. Bu stackâ€™in iÃ§inde sadece normal datatype lar deÄŸil bu ÅŸekilde baÅŸka containerlarda tutabileceÄŸini ifade eder.
    
    template <class Type, class Container = deque<Type> > class stack;
    
    <aside>
    ğŸ’¡ Burada ki satÄ±rÄ±n meali :
    Bir template sÄ±nÄ±f oluÅŸturuyor ve bu sÄ±nÄ±f iÃ§erisinde iki adet template deÄŸiÅŸken var.
    
    1. Class Type burada bizim dataTypeâ€™Ä±mÄ±zÄ± temsil ediyor.
    2. Class Container ise bir container sÄ±nÄ±fÄ± alÄ±caÄŸÄ±nÄ± sÃ¶ylÃ¼yor ancak herhangi bir container belirtilmesse default olarak deque olarak belirle ve dequeâ€™nin data typeâ€™Ä±na birinci paremetreyi veriyor. Bu sayade stack Class Type ile Deque Container Type â€˜Ä± aynÄ± olmuÅŸ oluyor.
    
    </aside>
    
    Bu <stack> header file iÃ§erisinde bulunan default stack tanÄ±mÄ±dÄ±r. Herhangi bir ÅŸekilde bir tip belirtmezsek stack iÃ§erisinde ki verileri deque container ile tutucaktÄ±r. 
    
    **Stack< int, vector <int> >Â myStack;** Bu ÅŸekilde yazarsak iÃ§erisinde  Vector olarak depolayÄ±p tutcaktÄ±r ancak eÄŸer
    **Stack<int> myStack;** yazsaydÄ±k bu seferde default deÄŸer olarak deque olarak depolayÄ±p tutucaktÄ±r.
    
    ![Ekran Resmi 2024-05-14 21.16.43.png](Stack%20785686561bd34e49ae4f21408b34bb98/Ekran_Resmi_2024-05-14_21.16.43.png)
    
    Bu nasÄ±l oluyor dicek olursanÄ±z ?
    
    ![Ekran Resmi 2024-05-17 17.23.12.png](Stack%20785686561bd34e49ae4f21408b34bb98/Ekran_Resmi_2024-05-17_17.23.12.png)
    
    Bu ekran [gÃ¶rÃ¼ntÃ¼sÃ¼](https://en.cppreference.com/w/cpp/container/stack) ÅŸu siteye ait.(GÃ¶rÃ¼ntÃ¼sÃ¼ Ã¼zerine tÄ±klayÄ±p gidebilirsin.) Ä°yi de bu nedemek? 
    
    AdaptÃ¶rler bildiÄŸiniz gibi bir container deÄŸildir. Bu yÃ¼zden direk STL kÃ¼tÃ¼phanesine ait fonksiyonlarÄ± kullanamÄ±yorlardÄ±. Åimdi biraz daha aÃ§Ä±klayÄ±cÄ± olalÄ±m.
    C++ referans sitesinde ki bu yer  std::stack sÄ±nÄ±fÄ±nÄ±n Container C ÅŸeklinde bir Ã¼ye tanÄ±mÄ±nÄ±n olduÄŸu gÃ¶steriyor. Bu ifade, std::stack sÄ±nÄ±fÄ±nÄ±n iÃ§inde bulunan ve genellikle **std::deque**, **std::vector** veya **std::list** gibi bir veri yapÄ±sÄ±nÄ± iÅŸaret eden bir Ã¼ye deÄŸiÅŸkeni olduÄŸunu sÃ¶ylÃ¼yor bize. Biraz yukarÄ±da ki ekran gÃ¶rÃ¼ntÃ¼sÃ¼nde <set> header file iÃ§erisinden bir constuructor tanÄ±mÄ± gÃ¶stermiÅŸtim. Orada dequeâ€™yi gÃ¶rmÃ¼ÅŸtÃ¼nÃ¼z.
    
    ![Ekran Resmi 2024-05-17 17.33.32.png](Stack%20785686561bd34e49ae4f21408b34bb98/Ekran_Resmi_2024-05-17_17.33.32.png)
    
    Burada da gÃ¶rdÃ¼ÄŸÃ¼nÃ¼z gibi Container_type câ€™yi gÃ¶rebiliyorsunuz. TanÄ±mÄ± yukarÄ±da Container *__*containertype olarak geÃ§iyor. Åimdi niye stack diye bir ÅŸey var dersen?
    Bu adaptÃ¶rler, mevcut veri yapÄ±larÄ±nÄ± farklÄ± eriÅŸim yÃ¶ntemleri veya sÄ±nÄ±rlamalar ile kullanmanÄ±zÄ± saÄŸlar. Stackte Ä±terator doÄŸrudan kullanamÄ±yoruz  iÃ§erisinde default olarak deque vb. bile olsa.
    
    <aside>
    ğŸ’¡ **Dip Not** : Siz ne kadar iÃ§erisinde vector kullansanÄ±zda LIFO mantÄ±ÄŸÄ± deÄŸiÅŸmez (DeÄŸiÅŸtirmenin bir yolu var ancak Ã¶nce stackâ€™i ve bu dediklerimi Ã¶ÄŸrenelim baÅŸta.). (LAST IN FIRST OUT) Vector de buna ayak uydurur ve yoluna devam eder. Neden peki iÃ§erisinde deque veya vector tutabiliyoruz gibi bir ÅŸey sorucak olursanÄ±z?
    
    Stack , aslÄ±nda bir arayÃ¼z veya sarma (wrapper) sÄ±nÄ±fÄ±dÄ±r. Bu, belirli bir veri yapÄ±sÄ±nÄ± (Ã¶rneÄŸin, **`vector`**, **`list`** veya **`deque`**) sarmalayan ve LIFO iÅŸlevselliÄŸini saÄŸlayan bir sÄ±nÄ±ftÄ±r. Ancak, **`std::stack`** sÄ±nÄ±fÄ±nÄ±n kendisi, bu veri yapÄ±larÄ±nÄ±n tÃ¼m iÅŸlevselliÄŸini sunmaz. Bunun yerine, yalnÄ±zca LIFO mantÄ±ÄŸÄ±na uygun olan iÅŸlevleri saÄŸlar. Bu, genellikle **`push`**, **`pop`** ve **`top`** gibi iÅŸlevlerdir.
    
    </aside>
    
    - C++ Kod ve ekran gÃ¶rÃ¼ntÃ¼Ã¼s ile  kullanÄ±m kanÄ±tÄ±.
        
        ```cpp
        #include <iostream>
        #include <stack>
        #include <vector>
        #include <typeinfo> // type_id iÃ§in
        
        int main() {
            // std::stack'Ä±n container_type'Ä±nÄ± belirlemek iÃ§in bir Ã¶rnek oluÅŸturuyoruz
            std::stack<int> myStack;
        		std::stack<int, std::vector<int> > myStack2;
            // container_type'Ä± auto ile belirliyoruz
            auto container_type = myStack.__get_container();
        		auto container_type2 = myStack2.__get_container();
            // container_type'Ä±n tÃ¼rÃ¼nÃ¼ yazdÄ±rÄ±yoruz
            std::cout << "container_type mystac : " << typeid(container_type).name() << std::endl;
            std::cout << "container_type mystack2: " << typeid(container_type2).name() << std::endl;
        
            // DiÄŸer iÅŸlemleri devam ettirebiliriz
            myStack.push(1);
            myStack.push(2);
            myStack.push(3);
        
            while (!myStack.empty()) {
                std::cout << myStack.top() << " "; // En Ã¼stteki elemanÄ± yazdÄ±r
                myStack.pop(); // En Ã¼stteki elemanÄ± Ã§Ä±kar
            }
        
            return 0;
        }
        ```
        
        ![Ekran Resmi 2024-05-17 17.46.23.png](Stack%20785686561bd34e49ae4f21408b34bb98/Ekran_Resmi_2024-05-17_17.46.23.png)
        

Stack ve Queue arasÄ±ndaki temel farkÄ± hatÄ±rlamakta kafa karÄ±ÅŸÄ±klÄ±ÄŸÄ± varsa, bu ayrÄ±m iÃ§in gerÃ§ek hayattan bir Ã¶rnek verelim, stack iÃ§in, kitaplarÄ±n istiflenmesi iÃ§in en Ã¼stteki kitabÄ± kolayca alabiliriz ve kuyruk iÃ§in ATM'nin Ã¶nÃ¼nde para Ã§ekmek iÃ§in kuyrukta durmanÄ±z gerektiÄŸinde, ATM'ye yakÄ±n olan ilk kiÅŸinin ATM'den parayÄ± almak iÃ§in ilk ÅŸansÄ± olduÄŸunu hatÄ±rlayÄ±n. Yani, kuyruk FIFO (Ä°lk Giren Ä°lk Ã‡Ä±kar) tipi bir Ã§alÄ±ÅŸmadÄ±r.

### Stack hangi durumlarda kullanÄ±lÄ±r?

> Stack elemanlarÄ±mÄ±zÄ± rastgele depolamak iÃ§in deÄŸil sÄ±ralÄ± kalmasÄ± gereken verilerimizi depolamak iÃ§in kullanÄ±rÄ±z. Bu durumlarda kullanmak iÃ§in tercih edilir.
> 

### Stack Syntax:

Bir yÄ±ÄŸÄ±n oluÅŸturmak iÃ§in kodumuza <stack> baÅŸlÄ±k dosyasÄ±nÄ± dahil etmeliyiz. Daha sonra std::stack'i tanÄ±mlamak iÃ§in bu sÃ¶z dizimini kullanÄ±rÄ±z:

```cpp
#include <iostream> 
#include <stack>
#include <vector>
#include <list>
using namespace std;
int main() {
	stack<int> stack1;
	stack<int, vector<int>> stack2;
	stack<int, list<int>> stack3;
	stack<int, deque<int>> stack4;//Stack1 ile farkÄ± yoktur.
}
```

### YÄ±ÄŸÄ±n ile iliÅŸkili fonksiyonlar ÅŸunlardÄ±r:

- empty() - YÄ±ÄŸÄ±nÄ±n boÅŸ olup olmadÄ±ÄŸÄ±nÄ± dÃ¶ndÃ¼rÃ¼r - Zaman KarmaÅŸÄ±klÄ±ÄŸÄ± : O(1)
- size() - YÄ±ÄŸÄ±nÄ±n boyutunu dÃ¶ndÃ¼rÃ¼r - Zaman KarmaÅŸÄ±klÄ±ÄŸÄ± : O(1)
- top() - YÄ±ÄŸÄ±nÄ±n en Ã¼stteki elemanÄ±na bir referans dÃ¶ndÃ¼rÃ¼r - Zaman KarmaÅŸÄ±klÄ±ÄŸÄ± : O(1)
- push(g) - 'g' elemanÄ±nÄ± yÄ±ÄŸÄ±nÄ±n en Ã¼stÃ¼ne ekler - Zaman KarmaÅŸÄ±klÄ±ÄŸÄ± : O(1)
- pop() - YÄ±ÄŸÄ±nÄ±n en son girilen elemanÄ±nÄ± siler - Zaman KarmaÅŸÄ±klÄ±ÄŸÄ± : O(1)

```cpp
#include <iostream> 
#include <stack>
using namespace std;
int main() {
	stack<int> stack;
	//Burada eklencek deÄŸerler stack define edilirken type ile aynÄ± olmalÄ±dÄ±r.
	stack.push(21);
	stack.push(22);
	stack.push(24);
	stack.push(25);
	int num=0;
	stack.push(num);
	stack.pop();
	stack.pop();
	stack.pop();

	while (!stack.empty()) {
		cout << stack.top() <<" ";
		stack.pop();
	}
	//Stack kopyasÄ±nÄ± alan bir print yazmadÄ±ÄŸÄ±mÄ±z iÃ§in tÃ¼m stack gg!
}
```

<aside>
ğŸ’¡ **Dip Not** : Siz ne kadar iÃ§erisinde vector kullansanÄ±zda LIFO mantÄ±ÄŸÄ± deÄŸiÅŸmez (DeÄŸiÅŸtirmenin bir yolu var ancak Ã¶nce stackâ€™i ve bu dediklerimi Ã¶ÄŸrenelim baÅŸta.). (LAST IN FIRST OUT) Vector de buna ayak uydurur ve yoluna devam eder. Neden peki iÃ§erisinde deque veya vector tutabiliyoruz gibi bir ÅŸey sorucak olursanÄ±z?

Stack , aslÄ±nda bir arayÃ¼z veya sarma (wrapper) sÄ±nÄ±fÄ±dÄ±r. Bu, belirli bir veri yapÄ±sÄ±nÄ± (Ã¶rneÄŸin, **`vector`**, **`list`** veya **`deque`**) sarmalayan ve LIFO iÅŸlevselliÄŸini saÄŸlayan bir sÄ±nÄ±ftÄ±r. Ancak, **`std::stack`** sÄ±nÄ±fÄ±nÄ±n kendisi, bu veri yapÄ±larÄ±nÄ±n tÃ¼m iÅŸlevselliÄŸini sunmaz. Bunun yerine, yalnÄ±zca LIFO mantÄ±ÄŸÄ±na uygun olan iÅŸlevleri saÄŸlar. Bu, genellikle **`push`**, **`pop`** ve **`top`** gibi iÅŸlevlerdir.

</aside>

### Stackâ€™te Iterator NasÄ±l KullanÄ±lÄ±r?

Bunu okuduÄŸun gibi aklÄ±na gelebilecek sorular;

- Åimdi bir saniye Ä±terator kullanamÄ±yorduk?
- Hani LIFO sistemi vardÄ±?

Åimdi evet LIFO sistemi var biliyoruz bunu. Ancak sayfa baÅŸÄ±nda ki toggle listâ€™e bir ÅŸeyler anlatmÄ±ÅŸtÄ±m. Stack iÃ§erisinde __container_type adÄ±nda bir protected Ã¼ye deÄŸiÅŸkeni olduÄŸunu sÃ¶ylemiÅŸtim. AynÄ± zamanda orada stack bir adaptÃ¶rdÃ¼r bir container deÄŸildir demiÅŸtik. Bir sarma(wrapper) sÄ±nÄ±f olduÄŸunu sÃ¶ylemiÅŸtim. 

Stack iÃ§erisinde kullandÄ±ÄŸÄ± ContainerlarÄ± farkli bir arayÃ¼zle ve sÄ±nÄ±rlamayla bizim Ã¶nÃ¼mÃ¼ze sunan bir adaptÃ¶r bunu biliyoruz. Åimdi iÃ§erisinde ki â€œcontainer_type câ€ Ã¼ye deÄŸiÅŸkeni sayesinde biz kullandÄ±ÄŸÄ±mÄ±z container sayesinde STL kÃ¼tÃ¼phanesine ulaÅŸabilir ve STL kÃ¼tÃ¼phanesine ait fonksiyonlarÄ± kullanabiliriz. Bunlardan biride iterator(yineleyiciler)â€™dÃ¼r. Bu sayede stackâ€™te normalde iterator/begin/end gibi fonksiyonlar olmasada kullanabiliriz. 

```cpp
#ifndef ITSTACK_HPP
# define ITSTACK_HPP

# include <iostream>
# include <algorithm>
# include <stack>
# include <list>
# include <vector>
# include <deque>

template <typename T, typename Container = std::deque<T> >
class ITStack : public std::stack<T>
{
	public:
		ITStack() : std::stack<T>(){}
		ITStack(const ITStack &other) : std::stack<T>(other){}
		ITStack &operator=(const ITStack &other){
			std::stack<T>::operator=(other);
			return *this;
		}
		~ITStack(){}

		typedef typename std::stack<T>::container_type::iterator iterator;
		//Stack sÄ±nÄ±fÄ±Ä±n iÃ§erisinde ki container_type sÄ±nÄ±fnÄ±n iÃ§erisinde ki iterator.
		//Bu sayede default da dequenin iteratorÃ¼ne ulaÅŸmÄ±ÅŸ olduk :)
		iterator begin(){
			return std::stack<T>::c.begin();
			//C Ã¼yesini kullandÄ±ÄŸÄ±mÄ±z yerlerden biri. 
		}

		iterator end(){ 
			return std::stack<T>::c.end(); 
		}
};

#endif

```

```cpp
#include "ITStack.hpp"

int main() {
    // ITStack tanÄ±mlama
    ITStack<int> stack;

    // Stack'e eleman ekleme
    stack.push(10);
    stack.push(20);
    stack.push(30);
    stack.push(40);
    stack.push(50);

    // Stack iÃ§eriÄŸini iteratÃ¶r kullanarak yazdÄ±rma
    std::cout << "Stack iÃ§eriÄŸi: ";
    for (ITStack<int>::iterator it = stack.begin(); it != stack.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    return 0;
}
```