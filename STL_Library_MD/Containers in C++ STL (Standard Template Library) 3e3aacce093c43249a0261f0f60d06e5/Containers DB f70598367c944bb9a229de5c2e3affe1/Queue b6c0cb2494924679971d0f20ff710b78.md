# Queue

Kuyruklar, ilk giren ilk Ã§Ä±kar (FIFO First-in-First-Out) tipi bir dÃ¼zenlemeyle Ã§alÄ±ÅŸan bir tÃ¼r container adaptÃ¶rÃ¼dÃ¼r. Ã–ÄŸeler arkadan (uÃ§tan) eklenir ve Ã¶nden silinir. Kuyruklar, temel kapsayÄ±cÄ± olarak deque veya list'in (sÄ±ralÄ± kapsayÄ±cÄ± sÄ±nÄ±fÄ±) kapsÃ¼llenmiÅŸ bir nesnesini kullanÄ±r ve Ã¶ÄŸelerine eriÅŸmek iÃ§in belirli bir Ã¼ye iÅŸlevler kÃ¼mesi saÄŸlar.

<aside>
ğŸ’¡ ÅÃ¶yle bir Ã¶rnek verebiliriz. Ramazan pidesi kuyruÄŸu ilk gelen ilk pidesini alÄ±p sÄ±radan Ã§Ä±kar.

</aside>

Syntax SÃ¶z dizimi ve nasÄ±l initialization nasÄ±l yapÄ±lÄ±r?

```cpp
#include <iostream>
#include <queue>
using namespace std;

int main()
{
	queue<int> myqueue; //Normal boÅŸ tanÄ±m.
	queue<int> myqueue2(myqueue);//Copyalama constructor ile tanÄ±m.
}
```

### Ãœye fonksiyonlarÄ±:

- **front() -**  Queueâ€™nin baÅŸÄ±nda ki elemanÄ±n referansÄ±nÄ± dÃ¶ndÃ¼rÃ¼r.
- **end() -**  Queueâ€™nin sonunda ki elemanÄ±n referansÄ±nÄ± dÃ¶ndÃ¼rÃ¼r.
- **empty() -** EÄŸer boÅŸssa True deÄŸilse False dÃ¶ndÃ¼rÃ¼r.
- **push() -** Queueâ€™nin sonuna eleman ekler. (â€x.push(value);â€)
- **pop() -** Kuyruk baÅŸÄ±ndan eleman siler. (FIFO First in First Out.)
- **size() -** Queueâ€™nin boyutunu geri dÃ¶ndÃ¼rÃ¼r.
- **swap() -** Ä°ki kuyruÄŸun iÃ§eriÄŸini deÄŸiÅŸtirir, ancak boyutlarÄ± farklÄ± olsa da kuyruklar aynÄ± veri tÃ¼rÃ¼nde olmalÄ±dÄ±r. ****

<aside>
ğŸ’¡ Queueâ€™lerde insert vb. bir method yoktur bunun nedeni kuyruklarda iterarot olmamasÄ±dÄ±r.

</aside>

```cpp
#include <iostream>
#include <queue>

using namespace std;

// Print the queue
void print_queue(queue<int> q)
{
	queue<int> temp = q;
	while (!temp.empty()) {
		cout << temp.front()<<" ";
		temp.pop();
		//referans veya pointer almayarak kopyasÄ±nÄ± aldÄ±ÄŸÄ±mÄ±zdan
		//silerek bÃ¼tÃ¼n kuyruÄŸu ekrana yazdÄ±rÄ±yoruz.
	}
	cout << '\n';
}

int main()
{
	queue<int> q1;
	q1.push(1);
	q1.push(2);
	q1.push(3);

	cout << "The first queue is : ";
	print_queue(q1);

	queue<int> q2;
	q2.push(4);
	q2.push(5);
	q2.push(6);

	cout << "The second queue is : ";
	print_queue(q2);

	q1.swap(q2);
	
	cout << "After swapping, the first queue is : ";
	print_queue(q1);
	cout << "After swapping the second queue is : ";
	print_queue(q2);

	cout<<q1.empty(); //returns false since q1 is not empty

	return 0;
}

```

---

**EÄŸer ilgileniyorsanÄ±z bu olaylardaki zaman karmaÅŸÄ±klÄ±ÄŸÄ± aÅŸaÄŸÄ±da ki gibidir.**

**print_queue fonksiyonu:**

Zaman karmaÅŸÄ±klÄ±ÄŸÄ±: O(n), burada n kuyruktaki eleman sayÄ±sÄ±dÄ±r.

Alan karmaÅŸÄ±klÄ±ÄŸÄ±: O(n), burada n kuyruktaki eleman sayÄ±sÄ±dÄ±r.

**Push:**

q1.push(1), q1.push(2), q1.push(3), q2.push(4), q2.push(5), q2.push(6):

Zaman karmaÅŸÄ±klÄ±ÄŸÄ±: Her bir itme iÅŸlemi iÃ§in O(1).

Alan karmaÅŸÄ±klÄ±ÄŸÄ±: O(n), burada n her iki kuyruktaki toplam eleman sayÄ±sÄ±dÄ±r.

**q1.swap(q2):**

Zaman karmaÅŸÄ±klÄ±ÄŸÄ±: Her takas iÅŸlemi iÃ§in O(1).

Alan karmaÅŸÄ±klÄ±ÄŸÄ±: O(1), Ã§Ã¼nkÃ¼ bu iÅŸlem yalnÄ±zca iki kuyruÄŸun dahili iÅŸaretÃ§ilerini deÄŸiÅŸtirir.

**q1.empty():**

Zaman karmaÅŸÄ±klÄ±ÄŸÄ±: O(1), Ã§Ã¼nkÃ¼ bu iÅŸlem sadece kuyruÄŸun boÅŸ olup olmadÄ±ÄŸÄ±nÄ± kontrol eder.

Alan karmaÅŸÄ±klÄ±ÄŸÄ±: O(1), Ã§Ã¼nkÃ¼ bu iÅŸlem iÃ§in fazladan alan kullanÄ±lmaz.

Genel olarak, bu kodun zaman ve alan karmaÅŸÄ±klÄ±klarÄ± tipik kullanÄ±m durumlarÄ± iÃ§in makul ve verimlidir.

| queue::empty() | O(1) |
| --- | --- |
| queue::size() | O(1) |
| queue::emplace() | O(1) |
| queue::front() | O(1) |
| queue::back() | O(1) |
| queue::push(g) | O(1) |
| queue::pop() | O(1) |
| queue::swap() | O(1) |