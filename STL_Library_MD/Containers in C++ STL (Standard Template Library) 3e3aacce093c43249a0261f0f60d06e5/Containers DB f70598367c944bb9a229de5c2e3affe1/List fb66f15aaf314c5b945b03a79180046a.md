# List

Listeler, bitiÅŸik olmayan bellek tahsisine izin veren sÄ±ra containerlardÄ±r.. VektÃ¶rle karÅŸÄ±laÅŸtÄ±rÄ±ldÄ±ÄŸÄ±nda, listenin geÃ§iÅŸi yavaÅŸtÄ±r, ancak bir konum bulunduÄŸunda, ekleme ve silme hÄ±zlÄ±dÄ±r (sabit zaman). Normalde, bir Liste dediÄŸimizde, Ã§ift baÄŸlÄ± bir listeden bahsederiz. Tek baÄŸlÄ± bir listeyi uygulamak iÃ§in bir forward_list kullanÄ±rÄ±z.

std::list, List container sÄ±nÄ±fÄ±dÄ±r. C++ Standart Åablon KÃ¼tÃ¼phanesi'nin (STL) bir parÃ§asÄ±dÄ±r ve <list> baÅŸlÄ±k dosyasÄ± iÃ§inde tanÄ±mlanÄ±r.

Syntax

> `std::list <data-type> name_of_list;`
> 

Ã–rnek :

```cpp
#include <iostream>
#include <list>
using namespace std;

int main()
{
	// defining list
	list<int> gqlist{12,45,8,6};

	for (std::list<int>::iterator it = gqlist.begin() ; it != gqlist.end() ; it++) {
		cout << *it << ' ';
	}
	return 0;
}
```

<aside>
ğŸ’¡ Dip Not : Bu kod c++11 ve sonrasÄ±nda Ã§alÄ±ÅŸacaktÄ±r Ã§Ã¼nkÃ¼ Ã¶nceki sÃ¼rÃ¼mlerde 

â€list<int> gqlist{12,45,8,6};â€ satÄ±rÄ±nda hata vericektir.

```
    list<int> gqlist{12,45,8,6};
                    ^
                    ;
```

</aside>

Bu bir initialization ÅŸekli ama bir den Ã§ok yapÄ±labilir kÄ±saca nasÄ±l yapÄ±lÄ±rmÄ±ÅŸ bakalÄ±m. (DetaylÄ± halini [vectorâ€™lerde](Vector%20b577d501d42b4bfbb6b49a8990723469.md) anlattÄ±m.

- **Initialization**:
    
    ```cpp
    #include <iostream>
    #include <list>
    using namespace std;
    
    int main()
    {
    //BoÅŸ List
    	list<int> mylist2;
    //Liste AÃ§arken Atama iÅŸlemi c++11 ve sonrasÄ±
    	list<int> mylist{12,45,8,6,23};
    // 5 Tane 10
    	list<int> mylist3(5, 10);
    // 10 BoÅŸ yer
    	list<int> mylist4(10);
    // Copy List
    	list<int> mylist5(mylist);
    }
    //<int> benim sadece basit olarak Ã¶rnek verdiÄŸim bir ÅŸey keyfine gÃ¶re
    //istediÄŸin bir ÅŸey de yazabilirisn type olarak.
    ```
    

### ***BazÄ± basit liste Ã¼ye fonksiyonlarÄ±:***

- [**front()](https://www.geeksforgeeks.org/list-front-function-in-c-stl/)Â â€“**Â Listedeki ilk elemanÄ±n deÄŸerini dÃ¶ndÃ¼rÃ¼r.
- [**back()](https://www.geeksforgeeks.org/list-back-function-in-c-stl/)Â â€“**Â Listedeki son elemanÄ±n deÄŸerini dÃ¶ndÃ¼rÃ¼r.
- [**push_front()](https://www.geeksforgeeks.org/list-push_front-function-in-c-stl/)Â â€“**Â Listenin baÅŸÄ±na yeni bir eleman Ã¶ÄŸesi ekler.
- [**push_back()](https://www.geeksforgeeks.org/list-push_back-function-in-c-stl/)Â â€“**Â Listenin sonuna yeni bir eleman Ã¶ÄŸesi ekler.
- [**pop_front()](https://www.geeksforgeeks.org/list-pop_front-function-in-c-stl/)Â â€“**Â Listenin ilk elemanÄ±nÄ± kaldÄ±rÄ±r ve listenin boyutunu 1 azaltÄ±r.
- [**pop_back()](https://www.geeksforgeeks.org/list-pop_back-function-in-c-stl/)Â â€“**Â Listenin son elemanÄ±nÄ± kaldÄ±rÄ±r ve listenin boyutunu 1 azaltÄ±r.
- [**insert()](https://www.geeksforgeeks.org/list-insert-in-c-stl/)Â â€“**Â Listeye, belirtilen konumdaki elemandan Ã¶nce yeni elemanlar ekler.
- [**size()](https://www.geeksforgeeks.org/list-size-function-in-c-stl/)Â â€“**Â Listedeki eleman sayÄ±sÄ±nÄ± dÃ¶ndÃ¼rÃ¼r.
- [**begin()](https://www.geeksforgeeks.org/listbegin-listend-c-stl/)Â â€“**Â begin() iÅŸlevi, listenin ilk Ã¶ÄŸesine iÅŸaret eden bir iterator dÃ¶ndÃ¼rÃ¼r.
- [**end()](https://www.geeksforgeeks.org/listbegin-listend-c-stl/)Â â€“**Â end() fonksiyonu, son elemanÄ± takip eden teorik son elemana iÅŸaret eden bir iterator dÃ¶ndÃ¼rÃ¼r.
- **clear()** **-** Listesnin iÃ§erisini tamamen temizler.
- **empty()** - Listenin iÃ§eriisnin boÅŸ olup olmadÄ±ÄŸÄ± hakkÄ±nda bize bilgi verir. True veya False dÃ¶ndÃ¼rÃ¼r.
- **erase()** - Listenin belirli bir yerinden belirli baÅŸka bir yerine kadar elemanlarÄ± silmek iÃ§in kullandÄ±ÄŸÄ±mÄ±z Ã¼ye fonksiyonu. Tek bir pozisyon verirsek sadece o pozisyondaki elemanÄ± silecektir.
- **resize()** - Listenin boyutunu yeniden belirleyebiliyoruz bu fonksiyon sayesinde.
- **merge()** - Ä°ki listeyi bir biriyle birleÅŸtirmemizi saÄŸlÄ±yor.
- **remove()** - Liste iÃ§erisinde belirtilen elemanÄ± siler. (FarklÄ± olarak ÅŸÃ¶yle bir Ã¶zelliÄŸi var listenin iÃ§erisinde 6 tane 1 varsa ve remove(1) dersek 6 tane 1â€™de silecektir.)
- **sort() -** Listeyi sÄ±ralar.
- **splice() -** Ä°lk paretresi bir pozisyon olup ikinci paremetresi bir listedir. Verilen listeyi verilen pozisyondan sonrasÄ±na ekler. (Merge gibidir ancak merge Ã§ok spesifik iÅŸlemler iÃ§inde kullanÄ±labilir farklÄ± algoritmalarla birleÅŸtirme Ã¶rnekleri vardÄ±r. Ã–rnek vericem.)
- **unique() -** Listeyi benzersiz yapmaya yarar. Liste iÃ§erisinde kendini tekrar eden elemanlarÄ± kaldÄ±rarak listeyi benzersiz(unique) bir hale getirir.(kÃ¼Ã§Ã¼k bir detay var eÄŸer liste sÄ±ralÄ± deÄŸilse dÃ¼zgÃ¼n Ã§alÄ±ÅŸmayacaktÄ±r bunun nedeni ise yanÄ±ndaki bir sonraki eleman ile karÅŸÄ±laÅŸtÄ±rma yaparak ilerliyor olmasÄ±. â€œ7, 8 , 7, 9â€ gibi bir listede herhangi bir eleman silmeyecektir.)

```cpp
#include <iostream>
#include <iterator>
#include <list>
using namespace std;

// Liste elemanlarÄ±nÄ± yazdÄ±ran kÃ¼Ã§Ã¼k bir fonksiyon.
void showlist(list<int> g)
{
	list<int>::iterator it;
	for (it = g.begin(); it != g.end(); ++it)
		cout << '\t' << *it;
	cout << '\n';
}

int main()
{

	list<int> gqlist1, gqlist2;

	for (int i = 0; i < 10; ++i) {
		gqlist1.push_back(i * 2);
		gqlist2.push_front(i * 3);
	}
	cout << "\nList 1 (gqlist1) is : ";
	showlist(gqlist1);

	cout << "\nList 2 (gqlist2) is : ";
	showlist(gqlist2);

	cout << "\ngqlist1.front() : " << gqlist1.front();
	cout << "\ngqlist1.back() : " << gqlist1.back();

	cout << "\ngqlist1.pop_front() : ";
	gqlist1.pop_front();
	showlist(gqlist1);

	cout << "\ngqlist2.pop_back() : ";
	gqlist2.pop_back();
	showlist(gqlist2);

	cout << "\ngqlist1.reverse() : ";
	gqlist1.reverse();
	showlist(gqlist1);

	cout << "\ngqlist2.sort(): ";
	gqlist2.sort();
	showlist(gqlist2);

	return 0;
}
```

- BirleÅŸtirme Splice ve Merge Ã–rnekleri:
    
    ```cpp
    #include <iostream>
    #include <list>
    using namespace std;
    
    void showlist(list<int> g)
    {
    	list<int>::iterator it;
    	for (it = g.begin(); it != g.end(); ++it)
    		cout << '\t' << *it;
    	cout << '\n';
    }
    
    int main()
    {
    	list<int> mylist1(5, 20);
    	list<int> mylist2(5, 10);
    	showlist(mylist1);
    	showlist(mylist2);
    	mylist1.splice(mylist1.end(), mylist2);
    	showlist(mylist1);
    	showlist(mylist2);
    	cout << '\t' << (mylist2.empty() ? "TRUE" : "FALSE") << endl;
    }
    ```
    
    ![Ekran Resmi 2024-05-14 16.08.50.png](List%20fb66f15aaf314c5b945b03a79180046a/Ekran_Resmi_2024-05-14_16.08.50.png)
    
    BakÄ±n gÃ¶rdÃ¼ÄŸÃ¼nÃ¼z gibi iki listeyi birleÅŸtirdek sonra â€œ**mylist2**â€ ekrana yazdÄ±rdÄ±ÄŸÄ±mÄ±zda boÅŸ bir satÄ±r gÃ¶rÃ¼yoruz. Bunun nedeni iki listeyi birleÅŸtirdiÄŸimizde artÄ±k birleÅŸtirilen listenin iÃ§erisi boÅŸalÄ±yor. Bu yÃ¼zden ikinci liste artÄ±k boÅŸ. Empty fonksiyonuda true dÃ¶ndÃ¼rÃ¼yor.
    
    Merge Ã–rneÄŸi:
    
    ```cpp
    #include <iostream>
    #include <list>
    using namespace std;
    
    void showlist(list<int> g)
    {
    	list<int>::iterator it;
    	for (it = g.begin(); it != g.end(); ++it)
    		cout << '\t' << *it;
    	cout << '\n';
    }
    
    int main()
    {
    	srand(time(NULL));
    	list<int> mylist1;
    	int value;
    	for (int i = 0; i < 10; i++){
    		value = rand() % 1000; // 0 ile 999 arasÄ± random sayÄ± atar.
    		mylist1.push_back(value);
    	}
    	list<int> mylist2;
    	for (int i = 0; i < 10; i++){
    		value = rand() % 1000; 
    		mylist2.push_back(value);
    	}
    
    	//iki adet listeyi random ÅŸekilde 10 elemanlÄ± olucak ÅŸekilde
    	//doldurduk.
    
    	//ÅŸimdi ikisinide sÄ±ralÄ± hale getirelim.
    	mylist1.sort();
    	mylist2.sort();
    
    	//SÄ±ralÄ± Listemizi gÃ¶relim.
    	showlist(mylist1);
    	showlist(mylist2);
    
    	mylist1.merge(mylist2);
    
    	showlist(mylist1);
    	showlist(mylist2);
    	//Åimdi iki sÄ±ralÄ± listemiz var.
    	//BunlarÄ± splice ile birleÅŸtirirsek bu sÄ±rayÄ± koruyamayÄ±z.
    	//Ancak merge ile yaparsak bu sÄ±rayÄ± koruyabiliriz.
    	//splice ile merge arasÄ±nda ki en bÃ¼yÃ¼k fark budur.
    	//merge ile birleÅŸtirme yaparken bir algoritmaya baÄŸlÄ± bir ÅŸekilde
    	//birleÅŸtirme iÅŸlemi yapaibilirisniz.
    
    }
    ```
    
    ![Ekran Resmi 2024-05-14 16.19.36.png](List%20fb66f15aaf314c5b945b03a79180046a/Ekran_Resmi_2024-05-14_16.19.36.png)
    
    GÃ¶rdÃ¼ÄŸÃ¼nÃ¼z gibi â€œ**mylist2**â€ listemiz yine boÅŸaldÄ±. Ancak splice ile arasÄ±nda ki fark ÅŸu merge listeyi birleÅŸtirirken iki listede sÄ±ralÄ± olduÄŸu iÃ§in bu sÄ±ralÄ± listeyi korudu ve dÃ¼zgÃ¼n bir ÅŸekilde sÄ±ralÄ± bir ÅŸekilde birleÅŸtirme iÅŸlemini gerÃ§ekleÅŸtirdi.
    

<aside>
ğŸ’¡ YukarÄ±daki Ã¶rnek sadece std::list ve Ã¼ye fonksiyonlarÄ±nÄ±n genel kullanÄ±mÄ±nÄ± gÃ¶stermektedir. [Geekforgeeks](https://www.geeksforgeeks.org/list-cpp-stl/) Ã¼zerinden tablo ÅŸeklinde std::list sÄ±nÄ±fÄ±nÄ±n tÃ¼m Ã¼ye fonksiyonlarÄ± ve detaylÄ± aÃ§Ä±klamalarÄ±na baÄŸlantÄ±lar verilmiÅŸtir.

</aside>

### Liste Container HakkÄ±nda UnutulmamasÄ± Gereken Noktalar

- Genellikle her iki yÃ¶nde de geÃ§iÅŸli dinamik bir Ã§ift baÄŸlÄ± liste kullanÄ±larak uygulanÄ±r.
- Dizilere ve vektÃ¶rlere kÄ±yasla daha hÄ±zlÄ± ekleme ve silme iÅŸlemi.
- Sadece sÄ±ralÄ± eriÅŸim saÄŸlar. Herhangi bir orta elemana rastgele eriÅŸim mÃ¼mkÃ¼n deÄŸildir
- Bir ÅŸablon olarak tanÄ±mlandÄ±ÄŸÄ±ndan herhangi bir veri tÃ¼rÃ¼nÃ¼ tutabilir.
- SÄ±ralanmamÄ±ÅŸ bir liste gibi Ã§alÄ±ÅŸÄ±r, bu da varsayÄ±lan olarak listenin sÄ±rasÄ±nÄ±n korunmadÄ±ÄŸÄ± anlamÄ±na gelir. Ancak, sÄ±ralama iÃ§in teknikler vardÄ±r.
- Vektorler genellikle kaÃ§ tane eleman eklenceÄŸi hakkÄ±nda bilgi sahibi olduÄŸumuz durumlarda kullanÄ±lÄ±rken listeler daha Ã§ok kaÃ§ tane veriyi tutucaÄŸÄ±mÄ±zÄ± bilmediÄŸimiz durumlarda kullanÄ±lÄ±r.