# Vector

VektÃ¶rler, bir Ã¶ÄŸe eklendiÄŸinde veya silindiÄŸinde kendilerini otomatik olarak yeniden boyutlandÄ±rma yeteneÄŸine sahip dinamik dizilerle aynÄ±dÄ±r ve depolanmalarÄ± container tarafÄ±ndan otomatik olarak gerÃ§ekleÅŸtirilir. 

VektÃ¶r Ã¶ÄŸeleri, iterators kullanÄ±larak eriÅŸilebilmeleri ve Ã§aprazlanabilmeleri iÃ§in bitiÅŸik depolama alanÄ±na yerleÅŸtirilir.

<aside>
ğŸ’¡ Ã‡aprazlanabilimeleri derken :  VektÃ¶r Ã¶ÄŸelerine doÄŸrudan eriÅŸim saÄŸlanabilmesi, Ã¶rneÄŸin, **`myVector[3]`** gibi , iterators kullanÄ±lmasÄ±nÄ±n bir diÄŸer yolunu vurgular. Iterators vektÃ¶rdeki Ã¶ÄŸeler arasÄ±nda gezinmeyi ve iÅŸlem yapmayÄ± kolaylaÅŸtÄ±rÄ±r. Ã–rneÄŸin, bir dÃ¶ngÃ¼ kullanarak tÃ¼m vektÃ¶r Ã¶ÄŸelerini iÅŸleyebiliriz.

BitiÅŸik Depolama AlanÄ±na YerleÅŸtirilir. : Ramde sÄ±ralÄ± bir ÅŸekilde yerleÅŸtirilmesinden bahseder.

</aside>

VektÃ¶rlerde veriler en sona eklenir. Bazen dizinin uzatÄ±lmasÄ± gerekebileceÄŸinden, sona ekleme n kadar verinin n kadar boyutu kadar zaman alÄ±r (Difransiyel Zaman alÄ±r. EÄŸer yer varsa bu sabit zaman alÄ±r ancak aksi durumda Difransiyel zaman alÄ±caktÄ±r.). 

Son elemanÄ±n silinmesi yalnÄ±zca sabit bir zaman alÄ±r Ã§Ã¼nkÃ¼ yeniden boyutlandÄ±rma gerÃ§ekleÅŸmez. BaÅŸlangÄ±Ã§ta veya ortada ekleme ve silme iÅŸlemi ise vetorÃ¼n ne kadar veri tuttuÄŸuna gÃ¶re (doÄŸrusal O(n) ) zaman alÄ±caktÄ±r.

## std::vector Nedir?

C++'da std::vector, vektÃ¶r containerâ€™Ä±nÄ± ve Ã¼ye methodlarÄ±nÄ± iÃ§eren class templateâ€™dir.  

<vector> header dosyasÄ± iÃ§inde tanÄ±mlanmÄ±ÅŸtÄ±r. std::vector classÄ±nÄ±n Ã¼ye fonksiyonlarÄ± vektÃ¶r containerâ€™Ä±n Ã§eÅŸitli iÅŸlevlerinin kullanÄ±lmasÄ±nÄ± saÄŸlar.

**C++â€™da Vector Declare (TanÄ±m) Syntaxâ€™Ä± nasÄ±l yapÄ±lÄ±r?**

> **`std::vector**<dataType> vectorName;`
Burada data type, vektÃ¶rÃ¼n her bir elemanÄ±nÄ±n veri tÃ¼rÃ¼dÃ¼r. EÄŸer â€œusing namespace std;â€ kullandÄ±ysanÄ±z std::â€™yi kaldÄ±rabilirsiniz.
> 

**C++â€™da Vectorâ€™Ã¼n Initialization (Atama) nasÄ±l yapÄ±lÄ±r?**

Bir vektÃ¶rÃ¼ birden Ã§ok ÅŸekilde **Initialization** edebiliriz. AÅŸadaÄŸÄ±dakiler bir vektÃ¶rÃ¼ nasÄ±l initialization edebileceÄŸimizin bir listesi:

**1.Â Initialization Using List: (Liste kullanarak baÅŸlatma iÅŸlemi)**

```cpp
#include <iostream>
#include <vector>

int main() {
    // Bir vektÃ¶r oluÅŸturup baÅŸlangÄ±Ã§ deÄŸerleri ile baÅŸlatma
    std::vector<int> numbers = {10, 20, 30, 40, 50};

    // VektÃ¶rdeki Ã¼Ã§Ã¼ncÃ¼ Ã¶ÄŸeyi ekrana yazdÄ±rma
    std::cout << numbers[2] << std::endl;

    return 0;
}
```

<aside>
ğŸ’¡ Dip not: EÄŸer kodu derlemeye Ã§alÄ±ÅŸÄ±rken hata alÄ±yorsanÄ±z derleyeciniz c++11 ve Ã¼stÃ¼nÃ¼ desteklemiyor demektir. Bunun iÃ§in g++ -std=c++11 x.cpp flagleri ile derleyebilirsiniz yada derleyicinizi gÃ¼ncelleyebilirsiniz.

</aside>

1. Â **InitializationÂ With a Single Value (Tek Bir DeÄŸerle BaÅŸlatma)**

Burada, vektÃ¶rÃ¼n boyutunu belirtiriz ve ardÄ±ndan vektÃ¶rÃ¼n her bir elemanÄ±nÄ± aynÄ± deÄŸerle baÅŸlatÄ±rÄ±z.

```cpp
#include <iostream>
#include <vector>

int main() {
    // Bir vektÃ¶r oluÅŸturup tek bir deÄŸerle baÅŸlatma
    std::vector<int> numbers(5, 100); // 5 eleman, her biri 100

    // VektÃ¶rdeki Ã¶ÄŸeleri ekrana yazdÄ±rma
    std::cout << "VektÃ¶rdeki Ã¶ÄŸeler: ";
    for (int num : numbers) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

### 3.Â **Initialization From Another Vector (BaÅŸka bir vektorâ€™un kopyasÄ± ile baÅŸlatma)**

Bu initialization, other_vec'in tam bir kopyasÄ± olan bir vektÃ¶r oluÅŸturmak iÃ§in kullanÄ±lÄ±r.

```cpp
#include <iostream>
#include <vector>

int main() {
    // Birinci vektÃ¶rÃ¼ oluÅŸturma ve baÅŸlangÄ±Ã§ deÄŸerleriyle baÅŸlatma
    std::vector<int> numbers1 = {1, 2, 3, 4, 5};

    // Ä°kinci vektÃ¶rÃ¼, birinci vektÃ¶rÃ¼n kopyasÄ± olarak oluÅŸturma
    std::vector<int> numbers2(numbers1); // numbers2, numbers1'in kopyasÄ±yla baÅŸlatÄ±lÄ±r

    // Ä°kinci vektÃ¶rdeki Ã¶ÄŸeleri ekrana yazdÄ±rma
    std::cout << "Ä°kinci vektÃ¶rdeki Ã¶ÄŸeler: ";
    for (int num : numbers2) {
        std::cout << num << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

### std::vector SÄ±nÄ±fÄ±nÄ±n YaygÄ±n Olarak KullanÄ±lan BazÄ± Ãœye FonksiyonlarÄ±:

- **Iterators Ãœye FonksiyonlarÄ±**
    1. [**begin()**](https://www.geeksforgeeks.org/vectorbegin-vectorend-c-stl/)Â â€“ VektÃ¶rdeki ilk Ã¶ÄŸeye iÅŸaret eden bir Iterator dÃ¶ndÃ¼rÃ¼r
    2. [**end()**](https://www.geeksforgeeks.org/vectorbegin-vectorend-c-stl/)Â â€“ VektÃ¶rdeki son elemanÄ± takip eden teorik elemana iÅŸaret eden bir Iterator dÃ¶ndÃ¼rÃ¼r
    3. [**rbegin()**](https://www.geeksforgeeks.org/vector-rbegin-and-rend-function-in-c-stl/)Â â€“ VektÃ¶rdeki son elemana iÅŸaret eden bir ters Iterator dÃ¶ndÃ¼rÃ¼r (ters baÅŸlangÄ±Ã§). Son elemandan ilk elemana doÄŸru hareket eder.
    4. [**rend()**](https://www.geeksforgeeks.org/vector-rbegin-and-rend-function-in-c-stl/)Â â€“ VektÃ¶rdeki ilk elemandan Ã¶nceki teorik elemana iÅŸaret eden bir ters Iterator dÃ¶ndÃ¼rÃ¼r (ters uÃ§ olarak kabul edilir)
    5. [**cbegin()**](https://www.geeksforgeeks.org/vector-cbegin-vector-cend-c-stl/)Â â€“ VektÃ¶rdeki ilk Ã¶ÄŸeye iÅŸaret eden sabit(constant) bir Iterator dÃ¶ndÃ¼rÃ¼r.
    6. [**cend()**](https://www.geeksforgeeks.org/vector-cbegin-vector-cend-c-stl/)Â â€“ bir vektÃ¶rdeki son Ã¶ÄŸeden sonraki hipotetik konumu iÅŸaret eden bir sabit (constant) iterator dÃ¶ndÃ¼rÃ¼r. (Hipotetik : gerÃ§ekte var olmayan veya gerÃ§ekleÅŸme ihtimali olan ancak kesin olmayan bir durumu veya durumun sonucunu ifade eder. KÄ±saca vektÃ¶rÃ¼n son elemanÄ±ndan sonraki boÅŸ yeri iÅŸaret ediyor.)
    7. [**crbegin()**](https://www.geeksforgeeks.org/vectorcrend-vectorcrbegin-examples/)Â â€“ VektÃ¶rdeki son elemana iÅŸaret eden sabit (constant) bir ters iterator dÃ¶ndÃ¼rÃ¼r (ters baÅŸlangÄ±Ã§). Son elemandan ilk elemana doÄŸru hareket eder
    8. [**crend()**](https://www.geeksforgeeks.org/vectorcrend-vectorcrbegin-examples/)Â â€“  VektÃ¶rdeki ilk elemandan Ã¶nceki teorik elemana iÅŸaret eden sabit (constant) bir ters iterator dÃ¶ndÃ¼rÃ¼r (ters uÃ§ olarak kabul edilir).
    
    ```cpp
    #include <iostream> 
    #include <vector> 
    using namespace std; 
    
    int main() 
    { 
    	vector<int> g1; 
    
    	for (int i = 1; i <= 5; i++) 
    		g1.push_back(i); 
    
    	cout << "Output of begin and end: "; 
    	for (auto i = g1.begin(); i != g1.end(); ++i) 
    		cout << *i << " "; 
    
    	cout << "\nOutput of cbegin and cend: "; 
    	for (auto i = g1.cbegin(); i != g1.cend(); ++i) 
    		cout << *i << " "; 
    
    	cout << "\nOutput of rbegin and rend: "; 
    	for (auto ir = g1.rbegin(); ir != g1.rend(); ++ir) 
    		cout << *ir << " "; 
    
    	cout << "\nOutput of crbegin and crend : "; 
    	for (auto ir = g1.crbegin(); ir != g1.crend(); ++ir) 
    		cout << *ir << " "; 
    
    	return 0; 
    } 
    ```
    
    <aside>
    ğŸ’¡ Buradaki auto kelimesi c++11 sonrasÄ±nda gelen bir key dir onun yerine std::vector<int>::iterator i de kullanÄ±labilir.
    
    </aside>
    
- **Capacity/Size (Kapasite/Boyut) Ãœye FonksiyonlarÄ±**
    1. [**size()**](https://www.geeksforgeeks.org/vectorempty-vectorsize-c-stl/)Â â€“ Vector iÃ§erisinde ki eleman sayÄ±sÄ±nÄ± dÃ¶ndÃ¼rÃ¼r.
    2. [**max_size()**](https://www.geeksforgeeks.org/vector-max_size-function-in-c-stl/)Â â€“ VektÃ¶rÃ¼n tutabileceÄŸi maksimum eleman sayÄ±sÄ±nÄ± dÃ¶ndÃ¼rÃ¼r.
    3. [**capacity()**](https://www.geeksforgeeks.org/vector-capacity-function-in-c-stl/)Â â€“ Eleman sayÄ±sÄ± olarak ifade edilen vektÃ¶re ayrÄ±lmÄ±ÅŸ depolama alanÄ±nÄ±n boyutunu dÃ¶ndÃ¼rÃ¼r.
    4. [**resize(n)**](https://www.geeksforgeeks.org/vector-resize-c-stl/)Â â€“ Containerâ€™Ä± 'n' Ã¶ÄŸe iÃ§erecek ÅŸekilde yeniden boyutlandÄ±rÄ±r.
    5. [**empty()**](https://www.geeksforgeeks.org/vectorempty-vectorsize-c-stl/)Â â€“ Containerâ€™Ä±n boÅŸ olup olmadÄ±ÄŸÄ±nÄ± dÃ¶ndÃ¼rÃ¼r.
    6. [**shrink_to_fit()**](https://www.geeksforgeeks.org/vector-shrink_to_fit-function-in-c-stl/)Â â€“ Containerâ€™Ä±n kapasitesini boyutuna uyacak ÅŸekilde azaltÄ±r ve kapasitenin Ã¶tesindeki tÃ¼m Ã¶ÄŸeleri yok eder.
    7. [**reserve()**](https://www.geeksforgeeks.org/using-stdvectorreserve-whenever-possible/)Â â€“ VektÃ¶r kapasitesinin en az n eleman iÃ§erecek kadar olmasÄ±nÄ± ister.
    
    ```cpp
    #include <iostream> 
    #include <vector> 
    
    using namespace std; 
    
    int main() 
    { 
    	vector<int> g1; 
    
    	for (int i = 1; i <= 5; i++) 
    		g1.push_back(i); 
    
    	cout << "Size : " << g1.size(); 
    	cout << "\nCapacity : " << g1.capacity(); 
    	cout << "\nMax_Size : " << g1.max_size(); 
    
    	// resizes the vector size to 4 
    	g1.resize(4); 
    
    	// prints the vector size after resize() 
    	cout << "\nSize : " << g1.size(); 
    
    	// checks if the vector is empty or not 
    	if (g1.empty() == false) 
    		cout << "\nVector is not empty"; 
    	else
    		cout << "\nVector is empty"; 
    
    	// Shrinks the vector 
    	g1.shrink_to_fit(); 
    	cout << "\nVector elements are: "; 
    	for (auto it = g1.begin(); it != g1.end(); it++) 
    		cout << *it << " "; 
    
    	return 0; 
    } 
    ```
    
- **Element access (Ã–ÄŸe eriÅŸimi) Ãœye FonksiyonlarÄ±**
    1. referans operatÃ¶rÃ¼ [g] - VektÃ¶rde 'g' konumundaki elemana bir referans dÃ¶ndÃ¼rÃ¼
    2. at(g) - VektÃ¶rde 'g' konumundaki elemana bir referans dÃ¶ndÃ¼rÃ¼r
    3. front() - VektÃ¶rdeki ilk elemana bir referans dÃ¶ndÃ¼rÃ¼r
    4. back() - VektÃ¶rdeki son elemana bir referans dÃ¶ndÃ¼rÃ¼r
    5. data() - Sahip olunan Ã¶ÄŸeleri saklamak iÃ§in vektÃ¶r tarafÄ±ndan dahili olarak kullanÄ±lan bellek dizisine doÄŸrudan bir iÅŸaretÃ§i dÃ¶ndÃ¼rÃ¼r.
    
    ```cpp
    #include <vector>
    #include <iostream>
    using namespace std; 
    
    int main() 
    { 
    	vector<int> g1; 
    
    	for (int i = 1; i <= 10; i++) 
    		g1.push_back(i * 10); 
    
    	cout << "\nReference operator [g] : g1[2] = " << g1[2]; 
    
    	cout << "\nat : g1.at(4) = " << g1.at(4); 
    
    	cout << "\nfront() : g1.front() = " << g1.front(); 
    
    	cout << "\nback() : g1.back() = " << g1.back(); 
    
    	// pointer to the first element 
    	int* pos = g1.data(); 
    
    	cout << "\nThe first element is " << *pos; 
    	return 0; 
    } 
    ```
    
- **Modifiers (DeÄŸiÅŸtirici ve dÃ¼zenleyici) Ãœye FonksiyonlarÄ±**
    1. [**assign()**](https://www.geeksforgeeks.org/vector-assign-in-c-stl/)Â â€“ VektÃ¶r elemanlarÄ±na eskilerini deÄŸiÅŸtirerek yeni deÄŸer atar. (x kadar yere, z deÄŸerini atar.)
    2. [**push_back()**](https://www.geeksforgeeks.org/vectorpush_back-vectorpop_back-c-stl/)Â â€“ Vector sonuna bir yeni eleman ekler.
    3. [**pop_back()**](https://www.geeksforgeeks.org/vectorpush_back-vectorpop_back-c-stl/)Â â€“ Vectorun son elemanÄ±nÄ± siler.
    4. [**insert()**](https://www.geeksforgeeks.org/vector-insert-function-in-c-stl/)Â â€“ Belirlenen bir yere yeni bir eleman ekler.
    5. [**erase()**](https://www.geeksforgeeks.org/vectorclear-vectorerase-c-stl/)Â â€“  Bir containerâ€™da belirtilen konum veya aralÄ±ktaki elemanlarÄ± silmek iÃ§in kullanÄ±lÄ±r.
    6. [**swap()**](https://www.geeksforgeeks.org/vectorat-vectorswap-c-stl/)Â â€“ Bir vektÃ¶rÃ¼n iÃ§eriÄŸini aynÄ± tipteki baÅŸka bir vektÃ¶rle deÄŸiÅŸtirmek iÃ§in kullanÄ±lÄ±r. Array deki swapten farklÄ± olarak boyutlar aynÄ± olmak zorunda deÄŸildir farklÄ± olabilir.
    7. [**clear()**](https://www.geeksforgeeks.org/vectorclear-vectorerase-c-stl/)Â â€“ Vektor iÃ§erisinde ki tÃ¼m elemanlarÄ± siler.
    8. [**emplace()**](https://www.geeksforgeeks.org/vector-emplace-function-in-c-stl/)Â â€“ Konumuna yeni eleman ekleyerek containerâ€™Ä± geniÅŸletir
    9. [**emplace_back()**](https://www.geeksforgeeks.org/vectoremplace_back-c-stl/)Â â€“ VektÃ¶r containerâ€™Ä±na yeni bir eleman eklemek iÃ§in kullanÄ±lÄ±r, yeni eleman vektÃ¶rÃ¼n sonuna eklenir.
    
    ```cpp
    #include <iostream>
    #include <vector> 
    using namespace std; 
    
    int main() 
    { 
    	// Assign vector 
    	vector<int> v; 
    
    	// fill the vector with 10 five times 
    	v.assign(5, 10); 
    
    	cout << "The vector elements are: "; 
    	for (int i = 0; i < v.size(); i++) 
    		cout << v[i] << " "; 
    
    	// inserts 15 to the last position 
    	v.push_back(15); 
    	int n = v.size(); 
    	cout << "\nThe last element is: " << v[n - 1]; 
    
    	// removes last element 
    	v.pop_back(); 
    
    	// prints the vector 
    	cout << "\nThe vector elements are: "; 
    	for (int i = 0; i < v.size(); i++) 
    		cout << v[i] << " "; 
    
    	// inserts 5 at the beginning 
    	v.insert(v.begin(), 5); 
    
    	cout << "\nThe first element is: " << v[0]; 
    
    	// removes the first element 
    	v.erase(v.begin()); 
    
    	cout << "\nThe first element is: " << v[0]; 
    
    	// inserts at the beginning 
    	v.emplace(v.begin(), 5); 
    	cout << "\nThe first element is: " << v[0]; 
    
    	// Inserts 20 at the end 
    	v.emplace_back(20); 
    	n = v.size(); 
    	cout << "\nThe last element is: " << v[n - 1]; 
    
    	// erases the vector 
    	v.clear(); 
    	cout << "\nVector size after clear(): " << v.size(); 
    
    	// two vector to perform swap 
    	vector<int> v1, v2; 
    	v1.push_back(1); 
    	v1.push_back(2); 
    	v2.push_back(3); 
    	v2.push_back(4); 
    
    	cout << "\n\nVector 1: "; 
    	for (int i = 0; i < v1.size(); i++) 
    		cout << v1[i] << " "; 
    
    	cout << "\nVector 2: "; 
    	for (int i = 0; i < v2.size(); i++) 
    		cout << v2[i] << " "; 
    
    	// Swaps v1 and v2 
    	v1.swap(v2); 
    
    	cout << "\nAfter Swap \nVector 1: "; 
    	for (int i = 0; i < v1.size(); i++) 
    		cout << v1[i] << " "; 
    
    	cout << "\nVector 2: "; 
    	for (int i = 0; i < v2.size(); i++) 
    		cout << v2[i] << " "; 
    } 
    ```
    

### **VektÃ¶rler Ã¼zerinde Ã§eÅŸitli iÅŸlemler yapmak iÃ§in zaman karmaÅŸÄ±klÄ±ÄŸÄ± :**

- Rastgele eriÅŸim - sabit O(1)
- Sona eleman ekleme veya Ã§Ä±karma - sabit O(1)
- Eleman ekleme veya Ã§Ä±karma - vektÃ¶rÃ¼n sonuna olan mesafede doÄŸrusal O(N)
- Boyutun bilinmesi - sabit O(1)
- VektÃ¶rÃ¼ yeniden boyutlandÄ±rma- DoÄŸrusal O(N)

<aside>
ğŸ’¡ Dip not : Vector kapasitesi dolduÄŸunda ve yeni eleman eklemek istediÄŸimizde size 2 katÄ±na Ã§Ä±kar ve bazen bu durum performans da kÃ¶tÃ¼ sonuÃ§lar vereceÄŸinden tercih dÄ±ÅŸÄ± kalabiliyor vectorler. Genellikle eleman sayÄ±sÄ± bilinmiyorsa listeler tercih ediliyor.

</aside>